<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Clear Storage - AI Evals Platform</title>
  <link rel="icon" type="image/jpeg" href="/favicon.jpeg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
  <style>
    /* Design System Tokens */
    :root {
      /* Colors - Brand */
      --color-brand-primary: #7030A0;
      --color-brand-primary-hover: #5C2680;
      --color-brand-accent: #C3C2F0;
      
      /* Colors - Neutral */
      --color-neutral-0: #FFFFFF;
      --color-neutral-50: #FBFAFF;
      --color-neutral-100: #F5F4F9;
      --color-neutral-200: #E8E7EE;
      --color-neutral-300: #D0CED9;
      --color-neutral-400: #A8A6B3;
      --color-neutral-500: #6B6B7B;
      --color-neutral-600: #49495A;
      --color-neutral-700: #363642;
      --color-neutral-800: #252530;
      --color-neutral-900: #1A1A24;
      
      /* Semantic */
      --bg-primary: var(--color-neutral-0);
      --bg-secondary: var(--color-neutral-50);
      --bg-tertiary: var(--color-neutral-100);
      --text-primary: var(--color-neutral-600);
      --text-secondary: var(--color-neutral-500);
      --text-muted: var(--color-neutral-400);
      --text-brand: var(--color-brand-primary);
      --border-default: var(--color-neutral-300);
      --border-subtle: var(--color-neutral-200);
      
      /* Semantic Colors */
      --color-success: #10B981;
      --color-success-light: #D1FAE5;
      --color-error: #EF4444;
      --color-error-light: #FEE2E2;
      --color-warning: #F59E0B;
      --color-warning-light: #FEF3C7;
      --color-info: #6366F1;
      --color-info-light: #E0E7FF;
      
      /* Typography */
      --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      --font-mono: 'JetBrains Mono', 'Fira Code', monospace;
      --text-xs: 11px;
      --text-sm: 13px;
      --text-base: 14px;
      --text-lg: 16px;
      
      /* Spacing & Radius */
      --radius-sm: 4px;
      --radius-default: 6px;
      --radius-lg: 8px;
      
      /* Shadows */
      --shadow-default: 0 1px 3px rgba(0, 0, 0, 0.06), 0 1px 2px rgba(0, 0, 0, 0.04);
      --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.05), 0 2px 4px rgba(0, 0, 0, 0.03);
    }
    
    [data-theme="dark"] {
      --bg-primary: var(--color-neutral-900);
      --bg-secondary: var(--color-neutral-800);
      --bg-tertiary: var(--color-neutral-700);
      --text-primary: var(--color-neutral-100);
      --text-secondary: var(--color-neutral-400);
      --text-muted: var(--color-neutral-500);
      --text-brand: var(--color-brand-accent);
      --border-default: var(--color-neutral-600);
      --border-subtle: var(--color-neutral-700);
      --color-success-light: rgba(16, 185, 129, 0.2);
      --color-error-light: rgba(239, 68, 68, 0.2);
      --color-warning-light: rgba(245, 158, 11, 0.2);
      --color-info-light: rgba(99, 102, 241, 0.2);
    }

    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: var(--font-sans);
      font-size: var(--text-base);
      line-height: 1.5;
      background-color: var(--bg-secondary);
      color: var(--text-primary);
      margin: 0;
      padding: 24px;
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
    }
    
    .container {
      max-width: 720px;
      margin: 0 auto;
    }
    
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 24px;
    }
    
    .header h1 {
      font-size: 20px;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .theme-toggle {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-default);
      padding: 8px 12px;
      cursor: pointer;
      font-size: var(--text-sm);
      color: var(--text-secondary);
      transition: all 0.15s ease;
    }
    
    .theme-toggle:hover {
      background: var(--border-subtle);
      color: var(--text-primary);
    }
    
    .card {
      background: var(--bg-primary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-lg);
      padding: 24px;
      margin-bottom: 16px;
      box-shadow: var(--shadow-default);
    }
    
    .card-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--border-subtle);
    }
    
    .card-header .icon {
      width: 40px;
      height: 40px;
      border-radius: var(--radius-default);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      background: var(--bg-tertiary);
    }
    
    .card-header .title {
      flex: 1;
    }
    
    .card-header h2 {
      font-size: var(--text-lg);
      font-weight: 600;
      color: var(--text-primary);
      margin: 0 0 2px 0;
    }
    
    .card-header p {
      font-size: var(--text-sm);
      color: var(--text-muted);
      margin: 0;
    }
    
    .alert {
      padding: 12px 16px;
      border-radius: var(--radius-default);
      font-size: var(--text-sm);
      margin-bottom: 16px;
    }
    
    .alert-warning {
      background: var(--color-warning-light);
      border: 1px solid var(--color-warning);
      color: var(--text-primary);
    }
    
    .alert-info {
      background: var(--color-info-light);
      border: 1px solid var(--color-info);
      color: var(--text-primary);
    }
    
    .alert-error {
      background: var(--color-error-light);
      border: 1px solid var(--color-error);
      color: var(--text-primary);
    }
    
    .alert strong {
      font-weight: 600;
    }
    
    .alert ul {
      margin: 8px 0 0 0;
      padding-left: 20px;
    }
    
    .alert li {
      margin: 4px 0;
    }
    
    .data-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .data-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: var(--bg-secondary);
      border-radius: var(--radius-default);
      font-size: var(--text-sm);
    }
    
    .data-item .label {
      color: var(--text-secondary);
    }
    
    .data-item .value {
      font-family: var(--font-mono);
      color: var(--text-primary);
    }
    
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 20px;
      border-radius: var(--radius-default);
      font-size: var(--text-sm);
      font-weight: 500;
      cursor: pointer;
      border: none;
      transition: all 0.15s ease;
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .btn-danger {
      background: var(--color-error);
      color: white;
    }
    
    .btn-danger:hover:not(:disabled) {
      background: #DC2626;
    }
    
    .btn-success {
      background: var(--color-success);
      color: white;
    }
    
    .btn-success:hover:not(:disabled) {
      background: #059669;
    }
    
    .btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border-default);
    }
    
    .btn-secondary:hover:not(:disabled) {
      background: var(--border-subtle);
    }
    
    .btn-group {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    
    .output {
      margin-top: 16px;
      padding: 16px;
      background: var(--bg-tertiary);
      border-radius: var(--radius-default);
      font-family: var(--font-mono);
      font-size: var(--text-xs);
      white-space: pre-wrap;
      max-height: 300px;
      overflow-y: auto;
      display: none;
      color: var(--text-secondary);
    }
    
    .output.show {
      display: block;
    }
    
    .output .success { color: var(--color-success); }
    .output .error { color: var(--color-error); }
    .output .info { color: var(--color-info); }
    
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: var(--radius-sm);
      font-size: var(--text-xs);
      font-weight: 500;
    }
    
    .badge-success {
      background: var(--color-success-light);
      color: var(--color-success);
    }
    
    .badge-warning {
      background: var(--color-warning-light);
      color: var(--color-warning);
    }
    
    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: var(--text-brand);
      text-decoration: none;
      font-size: var(--text-sm);
      font-weight: 500;
      margin-bottom: 16px;
    }
    
    .back-link:hover {
      text-decoration: underline;
    }
    
    .divider {
      height: 1px;
      background: var(--border-subtle);
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <a href="/" class="back-link">‚Üê Back to Application</a>
    
    <div class="header">
      <h1>üóëÔ∏è Storage Management</h1>
      <button class="theme-toggle" onclick="toggleTheme()">üåô Dark Mode</button>
    </div>

    <!-- Global Clear Card -->
    <div class="card">
      <div class="card-header">
        <div class="icon">üåê</div>
        <div class="title">
          <h2>Clear All Storage</h2>
          <p>Remove all data across all applications</p>
        </div>
        <span class="badge badge-warning">Destructive</span>
      </div>
      
      <div class="alert alert-error">
        <strong>‚ö†Ô∏è Warning:</strong> This will permanently delete ALL data including:
        <ul>
          <li>All app data (listings, files, chats, sessions)</li>
          <li>All evaluations, transcripts, and schemas</li>
          <li>All settings and preferences (including API keys)</li>
          <li>Service worker caches</li>
        </ul>
      </div>
      
      <div id="globalStats" class="data-list"></div>
      
      <div class="btn-group">
        <button class="btn btn-danger" onclick="clearAllStorage()">
          üóëÔ∏è Clear All Storage
        </button>
      </div>
      
      <div id="globalOutput" class="output"></div>
    </div>

    <!-- App-Specific Cards (dynamically generated) -->
    <div id="appCards"></div>
    
    <!-- Reload Card -->
    <div id="reloadCard" class="card" style="display: none;">
      <div class="card-header">
        <div class="icon">‚úÖ</div>
        <div class="title">
          <h2>Storage Cleared</h2>
          <p>Click below to restart the application with fresh data</p>
        </div>
        <span class="badge badge-success">Complete</span>
      </div>
      
      <button class="btn btn-success" onclick="reloadApp()">
        üîÑ Reload Application
      </button>
    </div>
  </div>

  <script>
    // =========================================================================
    // App Registry - Matches current project structure
    // =========================================================================
    const APP_REGISTRY = {
      'voice-rx': {
        id: 'voice-rx',
        name: 'Voice Rx',
        icon: 'üéôÔ∏è',
        description: 'Audio file evaluation tool',
        dataTypes: [
          'Listings & audio files (listings, files tables)',
          'Evaluations & transcripts',
          'Custom schemas & prompts (entities table)',
          'Evaluator definitions (entities table)',
          'Run history (history table)'
        ]
      },
      'kaira-bot': {
        id: 'kaira-bot',
        name: 'Kaira Bot',
        icon: 'ü§ñ',
        description: 'Health chat bot assistant',
        dataTypes: [
          'Chat sessions (entities table)',
          'Chat messages & history (entities table)',
          'User preferences'
        ]
      }
    };
    
    const DB_NAME = 'ai-evals-platform';
    
    // Current database schema (v2)
    const DB_TABLES = ['listings', 'files', 'entities', 'history'];
    const ENTITY_TYPES = ['setting', 'prompt', 'schema', 'chatSession', 'chatMessage', 'evaluator', 'tagRegistry'];
    
    // =========================================================================
    // Theme Management
    // =========================================================================
    function toggleTheme() {
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      document.documentElement.setAttribute('data-theme', isDark ? '' : 'dark');
      document.querySelector('.theme-toggle').textContent = isDark ? 'üåô Dark Mode' : '‚òÄÔ∏è Light Mode';
      localStorage.setItem('theme', isDark ? 'light' : 'dark');
    }
    
    function initTheme() {
      const savedTheme = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const theme = savedTheme || (prefersDark ? 'dark' : 'light');
      
      if (theme === 'dark') {
        document.documentElement.setAttribute('data-theme', 'dark');
        document.querySelector('.theme-toggle').textContent = '‚òÄÔ∏è Light Mode';
      }
    }
    
    // =========================================================================
    // Stats & Initialization
    // =========================================================================
    async function getStorageStats() {
      const stats = {
        databases: [],
        localStorage: { count: 0, size: 0 },
        caches: 0,
        storageEstimate: { used: 0, quota: 0 }
      };
      
      // IndexedDB databases
      if (indexedDB.databases) {
        stats.databases = await indexedDB.databases();
      }
      
      // localStorage
      stats.localStorage.count = localStorage.length;
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        stats.localStorage.size += (localStorage.getItem(key) || '').length;
      }
      
      // Caches
      if ('caches' in window) {
        const cacheNames = await caches.keys();
        stats.caches = cacheNames.length;
      }
      
      // Storage estimate
      if ('storage' in navigator && 'estimate' in navigator.storage) {
        const estimate = await navigator.storage.estimate();
        stats.storageEstimate = {
          used: estimate.usage || 0,
          quota: estimate.quota || 0
        };
      }
      
      return stats;
    }
    
    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    async function renderGlobalStats() {
      const stats = await getStorageStats();
      const container = document.getElementById('globalStats');
      
      container.innerHTML = `
        <div class="data-item">
          <span class="label">IndexedDB Databases</span>
          <span class="value">${stats.databases.length}</span>
        </div>
        <div class="data-item">
          <span class="label">LocalStorage Items</span>
          <span class="value">${stats.localStorage.count} (${formatBytes(stats.localStorage.size * 2)})</span>
        </div>
        <div class="data-item">
          <span class="label">Service Worker Caches</span>
          <span class="value">${stats.caches}</span>
        </div>
        <div class="data-item">
          <span class="label">Total Storage Used</span>
          <span class="value">${formatBytes(stats.storageEstimate.used)} / ${formatBytes(stats.storageEstimate.quota)}</span>
        </div>
      `;
    }
    
    async function getAppTableCounts(appId) {
      const app = APP_REGISTRY[appId];
      if (!app) return {};
      
      const counts = {};
      
      try {
        const request = indexedDB.open(DB_NAME);
        
        await new Promise((resolve, reject) => {
          request.onerror = () => reject(request.error);
          request.onsuccess = async () => {
            const db = request.result;
            
            try {
              // Count listings for this app
              if (db.objectStoreNames.contains('listings')) {
                const tx1 = db.transaction('listings', 'readonly');
                const listingsStore = tx1.objectStore('listings');
                const listingsIndex = listingsStore.index('appId');
                counts['listings'] = await new Promise((res) => {
                  const countRequest = listingsIndex.count(appId);
                  countRequest.onsuccess = () => res(countRequest.result);
                  countRequest.onerror = () => res(0);
                });
              }
              
              // Count entities for this app
              if (db.objectStoreNames.contains('entities')) {
                const tx2 = db.transaction('entities', 'readonly');
                const entitiesStore = tx2.objectStore('entities');
                const allEntities = await new Promise((res) => {
                  const getRequest = entitiesStore.getAll();
                  getRequest.onsuccess = () => res(getRequest.result);
                  getRequest.onerror = () => res([]);
                });
                
                // Filter by appId (prompts, schemas, evaluators, etc.)
                const appEntities = allEntities.filter(e => e.appId === appId);
                counts['entities'] = appEntities.length;
                
                // Break down by entity type
                const byType = {};
                appEntities.forEach(e => {
                  byType[e.type] = (byType[e.type] || 0) + 1;
                });
                counts['entities_by_type'] = byType;
                
                // For kaira-bot, count chat sessions and messages
                if (appId === 'kaira-bot') {
                  const chatSessions = allEntities.filter(e => e.type === 'chatSession' && e.appId === appId);
                  const chatMessages = allEntities.filter(e => e.type === 'chatMessage');
                  counts['chat_sessions'] = chatSessions.length;
                  counts['chat_messages'] = chatMessages.length;
                }
              }
              
              // Count history for this app
              if (db.objectStoreNames.contains('history')) {
                const tx3 = db.transaction('history', 'readonly');
                const historyStore = tx3.objectStore('history');
                const allHistory = await new Promise((res) => {
                  const getRequest = historyStore.getAll();
                  getRequest.onsuccess = () => res(getRequest.result);
                  getRequest.onerror = () => res([]);
                });
                counts['history'] = allHistory.filter(h => h.app_id === appId).length;
              }
            } catch (e) {
              console.warn('Error counting tables:', e);
            }
            
            db.close();
            resolve();
          };
        });
      } catch (e) {
        console.warn('Could not get table counts:', e);
      }
      
      return counts;
    }
    
    function renderAppCards() {
      const container = document.getElementById('appCards');
      container.innerHTML = '';
      
      for (const [appId, app] of Object.entries(APP_REGISTRY)) {
        const card = document.createElement('div');
        card.className = 'card';
        card.id = `card-${appId}`;
        card.innerHTML = `
          <div class="card-header">
            <div class="icon">${app.icon}</div>
            <div class="title">
              <h2>${app.name}</h2>
              <p>${app.description}</p>
            </div>
          </div>
          
          <div class="alert alert-info">
            <strong>‚ÑπÔ∏è This will clear:</strong>
            <ul>
              ${app.dataTypes.map(dt => `<li>${dt}</li>`).join('')}
            </ul>
          </div>
          
          <div id="stats-${appId}" class="data-list">
            <div class="data-item">
              <span class="label">Loading...</span>
              <span class="value">‚Äî</span>
            </div>
          </div>
          
          <div class="btn-group">
            <button class="btn btn-secondary" onclick="clearAppStorage('${appId}')">
              üóëÔ∏è Clear ${app.name} Data
            </button>
          </div>
          
          <div id="output-${appId}" class="output"></div>
        `;
        container.appendChild(card);
        
        // Load stats async
        loadAppStats(appId);
      }
    }
    
    async function loadAppStats(appId) {
      const app = APP_REGISTRY[appId];
      const container = document.getElementById(`stats-${appId}`);
      const counts = await getAppTableCounts(appId);
      
      let html = '';
      
      // Listings
      if (counts['listings'] !== undefined) {
        html += `
          <div class="data-item">
            <span class="label">Listings</span>
            <span class="value">${counts['listings']} records</span>
          </div>
        `;
      }
      
      // Entities breakdown
      if (counts['entities'] !== undefined) {
        html += `
          <div class="data-item">
            <span class="label">Entities (prompts, schemas, etc.)</span>
            <span class="value">${counts['entities']} records</span>
          </div>
        `;
        
        if (counts['entities_by_type']) {
          const types = counts['entities_by_type'];
          Object.keys(types).forEach(type => {
            html += `
              <div class="data-item" style="padding-left: 24px; opacity: 0.8;">
                <span class="label">‚Ü≥ ${type}</span>
                <span class="value">${types[type]}</span>
              </div>
            `;
          });
        }
      }
      
      // Chat-specific counts for kaira-bot
      if (appId === 'kaira-bot') {
        if (counts['chat_sessions'] !== undefined) {
          html += `
            <div class="data-item">
              <span class="label">Chat Sessions</span>
              <span class="value">${counts['chat_sessions']} sessions</span>
            </div>
          `;
        }
        if (counts['chat_messages'] !== undefined) {
          html += `
            <div class="data-item">
              <span class="label">Chat Messages</span>
              <span class="value">${counts['chat_messages']} messages</span>
            </div>
          `;
        }
      }
      
      // History
      if (counts['history'] !== undefined) {
        html += `
          <div class="data-item">
            <span class="label">Evaluator History</span>
            <span class="value">${counts['history']} runs</span>
          </div>
        `;
      }
      
      container.innerHTML = html || '<div class="data-item"><span class="label">No data</span><span class="value">‚Äî</span></div>';
    }
    
    // =========================================================================
    // Clear Storage Functions
    // =========================================================================
    function log(outputId, message, type = '') {
      const output = document.getElementById(outputId);
      output.classList.add('show');
      const span = document.createElement('span');
      span.className = type;
      span.textContent = message + '\n';
      output.appendChild(span);
      output.scrollTop = output.scrollHeight;
    }
    
    async function clearAllStorage() {
      const outputId = 'globalOutput';
      const output = document.getElementById(outputId);
      output.innerHTML = '';
      
      log(outputId, 'üöÄ Starting COMPLETE storage cleanup...', 'info');
      
      try {
        // 1. Clear IndexedDB databases
        log(outputId, '\nüì¶ Step 1: Clearing IndexedDB databases...');
        
        // Helper to delete with timeout
        const deleteDbWithTimeout = (dbName, timeoutMs = 2000) => {
          return new Promise((resolve) => {
            const timeout = setTimeout(() => {
              log(outputId, `   ‚ö† Timeout deleting: ${dbName} (blocked by another tab?)`, 'error');
              resolve();
            }, timeoutMs);
            
            try {
              const deleteRequest = indexedDB.deleteDatabase(dbName);
              deleteRequest.onsuccess = () => {
                clearTimeout(timeout);
                log(outputId, `   ‚úì Deleted: ${dbName}`, 'success');
                resolve();
              };
              deleteRequest.onerror = (e) => {
                clearTimeout(timeout);
                log(outputId, `   ‚úó Error deleting: ${dbName} - ${e.target?.error?.message || 'unknown'}`, 'error');
                resolve();
              };
              deleteRequest.onblocked = () => {
                clearTimeout(timeout);
                log(outputId, `   ‚ö† BLOCKED: ${dbName} - CLOSE ALL OTHER TABS WITH THIS APP!`, 'error');
                resolve();
              };
            } catch (e) {
              clearTimeout(timeout);
              log(outputId, `   ‚úó Exception: ${e.message}`, 'error');
              resolve();
            }
          });
        };
        
        if (indexedDB.databases) {
          try {
            const dbs = await Promise.race([
              indexedDB.databases(),
              new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 2000))
            ]);
            log(outputId, `   Found ${dbs.length} database(s): ${dbs.map(d => d.name).join(', ') || '(none)'}`);
            
            for (const dbInfo of dbs) {
              if (dbInfo.name) {
                await deleteDbWithTimeout(dbInfo.name);
              }
            }
          } catch (e) {
            log(outputId, `   ‚ö† Could not list databases: ${e.message}`, 'error');
          }
        }
        
        // Always try to delete known database names
        log(outputId, '   Deleting known database: ai-evals-platform');
        await deleteDbWithTimeout('ai-evals-platform');
        
        // 2. Clear ALL localStorage
        log(outputId, '\nüîë Step 2: Clearing ALL localStorage...');
        const localStorageKeys = [];
        for (let i = 0; i < localStorage.length; i++) {
          localStorageKeys.push(localStorage.key(i));
        }
        log(outputId, `   Found ${localStorageKeys.length} key(s): ${localStorageKeys.join(', ') || '(none)'}`);
        localStorage.clear();
        log(outputId, '   ‚úì localStorage cleared completely', 'success');
        
        // 3. Clear sessionStorage
        log(outputId, '\nüìù Step 3: Clearing sessionStorage...');
        const sessionStorageCount = sessionStorage.length;
        sessionStorage.clear();
        log(outputId, `   ‚úì Cleared ${sessionStorageCount} item(s)`, 'success');
        
        // 4. Clear service worker caches
        log(outputId, '\nüîÑ Step 4: Clearing service worker caches...');
        if ('caches' in window) {
          const cacheNames = await caches.keys();
          log(outputId, `   Found ${cacheNames.length} cache(s)`);
          for (const cacheName of cacheNames) {
            await caches.delete(cacheName);
            log(outputId, `   ‚úì Deleted: ${cacheName}`, 'success');
          }
          if (cacheNames.length === 0) {
            log(outputId, '   (no caches to clear)');
          }
        } else {
          log(outputId, '   No cache API available');
        }
        
        // 5. Unregister service workers
        log(outputId, '\nüõ†Ô∏è Step 5: Unregistering service workers...');
        if ('serviceWorker' in navigator) {
          const registrations = await navigator.serviceWorker.getRegistrations();
          log(outputId, `   Found ${registrations.length} service worker(s)`);
          for (const registration of registrations) {
            await registration.unregister();
            log(outputId, `   ‚úì Unregistered service worker`, 'success');
          }
          if (registrations.length === 0) {
            log(outputId, '   (no service workers to unregister)');
          }
        } else {
          log(outputId, '   No service worker API available');
        }
        
        log(outputId, '\n' + '='.repeat(50));
        log(outputId, '‚úÖ STORAGE CLEANUP COMPLETE!', 'success');
        log(outputId, '='.repeat(50));
        log(outputId, '\n‚ö†Ô∏è If you saw any "BLOCKED" messages above:');
        log(outputId, '   1. Close ALL other browser tabs with localhost:5173');
        log(outputId, '   2. Run this cleanup again');
        log(outputId, '\nClick "Reload Application" to start fresh.');
        
        // Show reload card
        document.getElementById('reloadCard').style.display = 'block';
        
        // Refresh stats
        await renderGlobalStats();
        
      } catch (error) {
        log(outputId, `\n‚ùå Error: ${error.message}`, 'error');
        console.error('Clear storage error:', error);
      }
    }
    
    async function clearAppStorage(appId) {
      const app = APP_REGISTRY[appId];
      if (!app) return;
      
      const outputId = `output-${appId}`;
      const output = document.getElementById(outputId);
      output.innerHTML = '';
      
      log(outputId, `üöÄ Clearing ${app.name} data...`, 'info');
      
      try {
        const request = indexedDB.open(DB_NAME);
        
        await new Promise((resolve, reject) => {
          request.onerror = () => reject(request.error);
          request.onsuccess = async () => {
            const db = request.result;
            let totalDeleted = 0;
            
            // Clear listings for this app
            if (db.objectStoreNames.contains('listings')) {
              try {
                const tx = db.transaction('listings', 'readwrite');
                const store = tx.objectStore('listings');
                const index = store.index('appId');
                const range = IDBKeyRange.only(appId);
                let deleted = 0;
                
                await new Promise((res) => {
                  const cursorRequest = index.openCursor(range);
                  cursorRequest.onsuccess = (e) => {
                    const cursor = e.target.result;
                    if (cursor) {
                      cursor.delete();
                      deleted++;
                      cursor.continue();
                    } else {
                      res();
                    }
                  };
                  cursorRequest.onerror = () => res();
                });
                
                log(outputId, `   ‚úì Cleared ${deleted} listings`, 'success');
                totalDeleted += deleted;
              } catch (e) {
                log(outputId, `   ‚ö† Could not clear listings: ${e.message}`, 'error');
              }
            }
            
            // Clear entities for this app
            if (db.objectStoreNames.contains('entities')) {
              try {
                const tx = db.transaction('entities', 'readwrite');
                const store = tx.objectStore('entities');
                let deleted = 0;
                
                // Get all entities and filter by appId
                const allEntities = await new Promise((res) => {
                  const getRequest = store.getAll();
                  getRequest.onsuccess = () => res(getRequest.result);
                  getRequest.onerror = () => res([]);
                });
                
                // Delete entities matching this appId
                for (const entity of allEntities) {
                  if (entity.appId === appId) {
                    await new Promise((res) => {
                      const deleteRequest = store.delete(entity.id);
                      deleteRequest.onsuccess = () => { deleted++; res(); };
                      deleteRequest.onerror = () => res();
                    });
                  }
                }
                
                log(outputId, `   ‚úì Cleared ${deleted} entities (prompts, schemas, evaluators, etc.)`, 'success');
                totalDeleted += deleted;
              } catch (e) {
                log(outputId, `   ‚ö† Could not clear entities: ${e.message}`, 'error');
              }
            }
            
            // Clear history for this app
            if (db.objectStoreNames.contains('history')) {
              try {
                const tx = db.transaction('history', 'readwrite');
                const store = tx.objectStore('history');
                let deleted = 0;
                
                const allHistory = await new Promise((res) => {
                  const getRequest = store.getAll();
                  getRequest.onsuccess = () => res(getRequest.result);
                  getRequest.onerror = () => res([]);
                });
                
                for (const entry of allHistory) {
                  if (entry.app_id === appId) {
                    await new Promise((res) => {
                      const deleteRequest = store.delete(entry.id);
                      deleteRequest.onsuccess = () => { deleted++; res(); };
                      deleteRequest.onerror = () => res();
                    });
                  }
                }
                
                log(outputId, `   ‚úì Cleared ${deleted} history entries`, 'success');
                totalDeleted += deleted;
              } catch (e) {
                log(outputId, `   ‚ö† Could not clear history: ${e.message}`, 'error');
              }
            }
            
            db.close();
            resolve();
          };
        });
        
        // Clear localStorage settings (but preserve API key)
        const settingsKey = `${appId}-settings`;
        const settingsRaw = localStorage.getItem(settingsKey);
        let apiKey = null;
        
        if (settingsRaw) {
          try {
            const settings = JSON.parse(settingsRaw);
            apiKey = settings?.state?.llm?.apiKey;
          } catch (e) {}
        }
        
        localStorage.removeItem(settingsKey);
        
        if (apiKey) {
          localStorage.setItem(settingsKey, JSON.stringify({
            state: { llm: { apiKey } },
            version: 0
          }));
          log(outputId, `   ‚úì Settings cleared (API key preserved)`);
        } else {
          log(outputId, `   ‚úì Settings cleared`);
        }
        
        log(outputId, `\n‚úÖ ${app.name} data cleared! (${totalDeleted} total records)`, 'success');
        
        // Refresh stats
        await loadAppStats(appId);
        await renderGlobalStats();
        
      } catch (error) {
        log(outputId, `\n‚ùå Error: ${error.message}`, 'error');
      }
    }
    
    function reloadApp() {
      window.location.href = '/';
    }
    
    // =========================================================================
    // Initialize
    // =========================================================================
    document.addEventListener('DOMContentLoaded', () => {
      initTheme();
      renderGlobalStats();
      renderAppCards();
    });
  </script>
</body>
</html>
