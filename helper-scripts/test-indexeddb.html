<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IndexedDB Diagnostic Test - AI Evals Platform</title>
  <link rel="icon" type="image/jpeg" href="/favicon.jpeg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
  <style>
    :root {
      --color-neutral-0: #FFFFFF;
      --color-neutral-100: #F5F4F9;
      --color-neutral-200: #E8E7EE;
      --color-neutral-300: #D0CED9;
      --color-neutral-400: #A8A6B3;
      --color-neutral-500: #6B6B7B;
      --color-neutral-600: #49495A;
      --color-neutral-700: #363642;
      --color-neutral-800: #252530;
      --color-neutral-900: #1A1A24;
      --color-brand-primary: #7030A0;
      --color-brand-accent: #C3C2F0;
      
      --bg-primary: var(--color-neutral-900);
      --bg-secondary: var(--color-neutral-800);
      --bg-tertiary: var(--color-neutral-700);
      --text-primary: var(--color-neutral-100);
      --text-secondary: var(--color-neutral-400);
      --text-muted: var(--color-neutral-500);
      --border-default: var(--color-neutral-600);
      --border-subtle: var(--color-neutral-700);
      
      --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      --font-mono: 'JetBrains Mono', 'Fira Code', monospace;
    }
    
    * { box-sizing: border-box; }
    
    body { 
      font-family: var(--font-sans);
      padding: 24px;
      background: var(--bg-primary);
      color: var(--text-primary);
      margin: 0;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
    }
    
    .container {
      max-width: 900px;
      margin: 0 auto;
    }
    
    h1 {
      font-size: 24px;
      font-weight: 600;
      margin: 0 0 8px 0;
      color: var(--text-primary);
    }
    
    .subtitle {
      color: var(--text-secondary);
      font-size: 14px;
      margin-bottom: 24px;
    }
    
    .controls {
      display: flex;
      gap: 12px;
      margin-bottom: 24px;
    }
    
    button {
      padding: 10px 20px;
      border-radius: 6px;
      border: 1px solid var(--border-default);
      background: var(--bg-secondary);
      color: var(--text-primary);
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.15s ease;
      font-family: var(--font-sans);
    }
    
    button:hover {
      background: var(--bg-tertiary);
      border-color: var(--border-default);
    }
    
    pre {
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: 8px;
      padding: 16px;
      overflow-x: auto;
      font-family: var(--font-mono);
      font-size: 12px;
      line-height: 1.6;
      color: var(--text-secondary);
    }
    
    .success { color: #34D399; }
    .error { color: #F87171; }
    .info { color: #60A5FA; }
    .warning { color: #FBBF24; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üî¨ IndexedDB Diagnostic Test</h1>
    <p class="subtitle">Tests raw IndexedDB API without Dexie to diagnose database issues</p>
    
    <div class="controls">
      <button onclick="runAllTests()">‚ñ∂Ô∏è Run All Tests</button>
      <button onclick="location.reload()">üîÑ Refresh Page</button>
    </div>
    
    <pre id="output"></pre>
  </div>

  <script>
    const TEST_DB_NAME = 'test-raw-indexeddb-' + Date.now();
    const PRODUCTION_DB_NAME = 'ai-evals-platform';
    
    function log(msg, type = '') {
      const output = document.getElementById('output');
      const span = document.createElement('span');
      span.className = type;
      span.textContent = msg + '\n';
      output.appendChild(span);
      console.log(msg);
    }
    
    function clearLog() {
      document.getElementById('output').innerHTML = '';
    }
    
    // Test 1: Can we even access indexedDB?
    async function testIndexedDBAccess() {
      log('\n=== Test 1: IndexedDB API Access ===', 'info');
      
      if (!window.indexedDB) {
        log('FAIL: indexedDB is not available', 'error');
        return false;
      }
      log('PASS: indexedDB API is available', 'success');
      return true;
    }
    
    // Test 2: Can we list databases?
    async function testListDatabases() {
      log('\n=== Test 2: List Databases ===', 'info');
      
      if (!indexedDB.databases) {
        log('SKIP: indexedDB.databases() not supported', 'info');
        return true;
      }
      
      try {
        const startTime = Date.now();
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Timeout after 3s')), 3000)
        );
        
        const dbs = await Promise.race([
          indexedDB.databases(),
          timeoutPromise
        ]);
        
        const elapsed = Date.now() - startTime;
        log(`PASS: Listed ${dbs.length} database(s) in ${elapsed}ms`, 'success');
        dbs.forEach(db => log(`  - ${db.name} (v${db.version})`));
        return true;
      } catch (err) {
        log(`FAIL: ${err.message}`, 'error');
        return false;
      }
    }
    
    // Test 3: Can we open a new database?
    async function testOpenDatabase() {
      log('\n=== Test 3: Open New Database ===', 'info');
      log(`Testing with DB name: ${TEST_DB_NAME}`);
      
      return new Promise((resolve) => {
        const startTime = Date.now();
        const timeout = setTimeout(() => {
          log(`FAIL: Database open timed out after 5 seconds`, 'error');
          log('This suggests IndexedDB is completely blocked!', 'error');
          resolve(false);
        }, 5000);
        
        try {
          const request = indexedDB.open(TEST_DB_NAME, 1);
          
          request.onerror = (event) => {
            clearTimeout(timeout);
            log(`FAIL: Error opening database: ${event.target.error}`, 'error');
            resolve(false);
          };
          
          request.onblocked = () => {
            log('WARNING: Database open blocked (another connection exists)', 'error');
            // Don't resolve yet, might still succeed
          };
          
          request.onupgradeneeded = (event) => {
            const elapsed = Date.now() - startTime;
            log(`onupgradeneeded fired after ${elapsed}ms`, 'info');
            const db = event.target.result;
            db.createObjectStore('test', { keyPath: 'id' });
            log('Created object store', 'info');
          };
          
          request.onsuccess = (event) => {
            clearTimeout(timeout);
            const elapsed = Date.now() - startTime;
            const db = event.target.result;
            log(`PASS: Database opened in ${elapsed}ms`, 'success');
            log(`  Version: ${db.version}`);
            log(`  Object stores: ${Array.from(db.objectStoreNames).join(', ')}`);
            
            // Store reference for later tests
            window.testDb = db;
            resolve(true);
          };
        } catch (err) {
          clearTimeout(timeout);
          log(`FAIL: Exception: ${err.message}`, 'error');
          resolve(false);
        }
      });
    }
    
    // Test 4: Can we write data?
    async function testWriteData() {
      log('\n=== Test 4: Write Data ===', 'info');
      
      if (!window.testDb) {
        log('SKIP: No database connection', 'info');
        return false;
      }
      
      return new Promise((resolve) => {
        try {
          const tx = window.testDb.transaction('test', 'readwrite');
          const store = tx.objectStore('test');
          
          const data = { id: 'test1', value: 'Hello IndexedDB', timestamp: Date.now() };
          const request = store.put(data);
          
          request.onsuccess = () => {
            log('PASS: Data written successfully', 'success');
            resolve(true);
          };
          
          request.onerror = (event) => {
            log(`FAIL: Error writing: ${event.target.error}`, 'error');
            resolve(false);
          };
        } catch (err) {
          log(`FAIL: Exception: ${err.message}`, 'error');
          resolve(false);
        }
      });
    }
    
    // Test 5: Can we read data?
    async function testReadData() {
      log('\n=== Test 5: Read Data ===', 'info');
      
      if (!window.testDb) {
        log('SKIP: No database connection', 'info');
        return false;
      }
      
      return new Promise((resolve) => {
        try {
          const tx = window.testDb.transaction('test', 'readonly');
          const store = tx.objectStore('test');
          const request = store.get('test1');
          
          request.onsuccess = (event) => {
            const data = event.target.result;
            if (data) {
              log('PASS: Data read successfully', 'success');
              log(`  Value: ${JSON.stringify(data)}`);
              resolve(true);
            } else {
              log('FAIL: No data found', 'error');
              resolve(false);
            }
          };
          
          request.onerror = (event) => {
            log(`FAIL: Error reading: ${event.target.error}`, 'error');
            resolve(false);
          };
        } catch (err) {
          log(`FAIL: Exception: ${err.message}`, 'error');
          resolve(false);
        }
      });
    }
    
    // Test 6: Can we delete the database?
    async function testDeleteDatabase() {
      log('\n=== Test 6: Delete Database ===', 'info');
      
      // Close the connection first
      if (window.testDb) {
        window.testDb.close();
        log('Closed database connection', 'info');
      }
      
      return new Promise((resolve) => {
        const startTime = Date.now();
        const timeout = setTimeout(() => {
          log(`FAIL: Delete timed out after 3 seconds`, 'error');
          resolve(false);
        }, 3000);
        
        const request = indexedDB.deleteDatabase(TEST_DB_NAME);
        
        request.onblocked = () => {
          log('WARNING: Delete blocked', 'error');
        };
        
        request.onsuccess = () => {
          clearTimeout(timeout);
          const elapsed = Date.now() - startTime;
          log(`PASS: Database deleted in ${elapsed}ms`, 'success');
          resolve(true);
        };
        
        request.onerror = (event) => {
          clearTimeout(timeout);
          log(`FAIL: Error deleting: ${event.target.error}`, 'error');
          resolve(false);
        };
      });
    }
    
    // Test 7: Check for existing production database
    async function testExistingDatabases() {
      log('\n=== Test 7: Check Production Database ===', 'info');
      
      log(`\nChecking production database: ${PRODUCTION_DB_NAME}...`);
      
      const result = await new Promise((resolve) => {
        const timeout = setTimeout(() => {
          log(`  ‚ùå TIMEOUT: Database open is hanging (2s) - IndexedDB is BLOCKED`, 'error');
          resolve('timeout');
        }, 2000);
        
        const request = indexedDB.open(PRODUCTION_DB_NAME);
        
        request.onsuccess = (event) => {
          clearTimeout(timeout);
          const db = event.target.result;
          const tables = Array.from(db.objectStoreNames);
          log(`  ‚úÖ OK: v${db.version}`, 'success');
          log(`  Tables: ${tables.join(', ')}`, 'info');
          
          // Check table counts
          const expectedTables = ['listings', 'files', 'entities', 'history'];
          const missingTables = expectedTables.filter(t => !tables.includes(t));
          const extraTables = tables.filter(t => !expectedTables.includes(t));
          
          if (missingTables.length > 0) {
            log(`  ‚ö†Ô∏è  Missing tables: ${missingTables.join(', ')}`, 'warning');
          }
          if (extraTables.length > 0) {
            log(`  ‚ÑπÔ∏è  Extra tables: ${extraTables.join(', ')}`, 'info');
          }
          if (missingTables.length === 0 && extraTables.length === 0) {
            log(`  ‚úÖ Schema matches expected (v2)`, 'success');
          }
          
          db.close();
          resolve('ok');
        };
        
        request.onerror = (event) => {
          clearTimeout(timeout);
          log(`  ‚ùå ERROR: ${event.target.error}`, 'error');
          resolve('error');
        };
        
        request.onblocked = () => {
          log(`  ‚ö†Ô∏è  BLOCKED: Another tab has this database open`, 'warning');
        };
      });
      
      if (result === 'timeout') {
        log(`\n*** DATABASE IS BLOCKING ALL OPERATIONS ***`, 'error');
        log('This database is preventing IndexedDB from working!', 'error');
        log('\nTroubleshooting:', 'info');
        log('1. Close ALL browser tabs with localhost:5173', 'info');
        log('2. Clear site data: DevTools > Application > Storage > Clear site data', 'info');
        log('3. Try a different browser (Firefox/Safari)', 'info');
      }
      
      return true;
    }
    
    async function runAllTests() {
      clearLog();
      log('üöÄ Starting IndexedDB Diagnostic Tests...', 'info');
      log(`Browser: ${navigator.userAgent.substring(0, 80)}...`);
      log(`Time: ${new Date().toISOString()}\n`);
      
      const results = {
        access: await testIndexedDBAccess(),
        list: await testListDatabases(),
        production: await testExistingDatabases(),
        open: await testOpenDatabase(),
        write: await testWriteData(),
        read: await testReadData(),
        delete: await testDeleteDatabase(),
      };
      
      log('\n' + '='.repeat(60), 'info');
      log('üìä TEST SUMMARY', 'info');
      log('='.repeat(60), 'info');
      
      const passed = Object.values(results).filter(r => r).length;
      const total = Object.keys(results).length;
      
      Object.entries(results).forEach(([test, result]) => {
        const icon = result ? '‚úÖ' : '‚ùå';
        const status = result ? 'PASS' : 'FAIL';
        log(`${icon} ${test.padEnd(15)} ${status}`, result ? 'success' : 'error');
      });
      
      log('\n' + '='.repeat(60));
      log(`Result: ${passed}/${total} tests passed`, passed === total ? 'success' : 'error');
      
      if (passed < total) {
        log('\nüîç DIAGNOSIS:', 'warning');
        if (!results.access) {
          log('- IndexedDB API is not available in this browser', 'error');
        }
        if (!results.open) {
          log('- IndexedDB open() is failing or hanging', 'error');
          log('- This blocks ALL IndexedDB operations', 'error');
        }
        if (!results.production) {
          log('- Production database has issues', 'error');
        }
        
        log('\nüí° SOLUTIONS:', 'info');
        log('1. Close ALL other tabs running localhost:5173', 'info');
        log('2. DevTools > Application > Storage > Clear site data', 'info');
        log('3. Try chrome://settings/content/all > Delete localhost data', 'info');
        log('4. Try a different browser (Firefox/Safari)', 'info');
        log('5. Check browser console for additional errors', 'info');
      } else {
        log('\n‚úÖ All tests passed! IndexedDB is working correctly.', 'success');
      }
    }
    
    // Auto-run on load
    window.onload = runAllTests;
  </script>
</body>
</html>
